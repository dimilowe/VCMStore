Yeah, this is exactly the right moment to lock it all in. I’ll tighten the Money Truth (offer_key) and the Sitemap → URL Registry contract. You can drop this straight into Replit and wire it up.
1. Formalizing the MONEY contract: offer_key is law
Right now:
Webhook uses payment_intent + product_slug. That’s brittle and tied to URLs.
From now on, the rule is:
All monetized things are identified by offer_key, not slug, not product name, not price amount.
1.1. Add offer_key to CMS product_data (contract)
In your CMS JSON schema / TypeScript type, make this mandatory for anything that uses Stripe:
// types/cms.ts
export type ProductData = {
  primary_price_id: string | null;        // null for external strategy
  mode: "payment" | "subscription" | null;

  checkout_strategy: "stripe" | "external";

  offer_key?: string;                     // <-- REQUIRED when checkout_strategy = "stripe"

  // Optional routing helpers:
  success_path?: string | null;
  cancel_path?: string | null;

  // rest of your product fields...
};
Rule:
If checkout_strategy === "stripe", offer_key must be present.
If checkout_strategy === "external", offer_key may be omitted (no Stripe).
Example CMS product_data for Rolodex:
"product_data": {
  "checkout_strategy": "stripe",
  "primary_price_id": "price_1QXYZ...ROLLODEX",
  "mode": "payment",
  "offer_key": "ROLLODEX_LIFETIME",
  "success_path": "/thanks/rolodex",
  "cancel_path": "/products/ultimatebranddealrolodex1"
}
1.2. Checkout: always pass offer_key + cmsSlug into Stripe metadata
Update /api/checkout to stop inferring anything from slugs. It should only trust CMS data.
// app/api/checkout/route.ts (Next.js App Router example)
import Stripe from "stripe";
import { getUserId } from "@/lib/auth";
import { getCmsObjectBySlug } from "@/lib/cms";

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: "2024-06-20" as any,
});

export async function POST(req: Request) {
  const { slug } = await req.json(); // frontend sends just slug

  const cmsObject = await getCmsObjectBySlug(slug);
  if (!cmsObject || cmsObject.type !== "product") {
    return new Response("Unknown product", { status: 400 });
  }

  const data = cmsObject.data.product_data;
  if (!data || data.checkout_strategy !== "stripe") {
    return new Response("Product not configured for Stripe checkout", { status: 400 });
  }

  if (!data.primary_price_id || !data.mode || !data.offer_key) {
    return new Response("Incomplete Stripe config on product", { status: 500 });
  }

  const userId = await getUserId(req);
  if (!userId) {
    return new Response("Unauthorized", { status: 401 });
  }

  const origin =
    process.env.NEXT_PUBLIC_SITE_URL ?? "https://yourdomain.com";

  const successUrl =
    data.success_path
      ? `${origin}${data.success_path}`
      : `${origin}/thanks/${cmsObject.slug}`;

  const cancelUrl =
    data.cancel_path
      ? `${origin}${data.cancel_path}`
      : `${origin}/products/${cmsObject.slug}`;

  const session = await stripe.checkout.sessions.create({
    mode: data.mode, // "payment" or "subscription"
    line_items: [
      {
        price: data.primary_price_id,
        quantity: 1,
      },
    ],
    success_url: successUrl,
    cancel_url: cancelUrl,
    metadata: {
      offer_key: data.offer_key,
      cms_slug: cmsObject.slug,
      user_id: userId,
    },
  });

  return new Response(JSON.stringify({ url: session.url }), {
    status: 200,
    headers: { "Content-Type": "application/json" },
  });
}
Key changes:
No more product_slug magic.
Everything comes from CMS: primary_price_id, mode, offer_key.
Stripe metadata is the single bridge: offer_key, cms_slug, user_id.
1.3. Webhook: grant entitlements purely by offer_key
Now fix the webhook so it never tries to infer from product_slug or anything else.
// app/api/stripe/webhook/route.ts
import Stripe from "stripe";
import { NextRequest } from "next/server";
import { grantAccessForOffer } from "@/lib/offers";

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: "2024-06-20" as any,
});

export async function POST(req: NextRequest) {
  const sig = req.headers.get("stripe-signature");
  if (!sig) return new Response("Missing signature", { status: 400 });

  const buf = await req.arrayBuffer();

  let event: Stripe.Event;
  try {
    event = stripe.webhooks.constructEvent(
      Buffer.from(buf),
      sig,
      process.env.STRIPE_WEBHOOK_SECRET!,
    );
  } catch (err: any) {
    return new Response(`Webhook Error: ${err.message}`, { status: 400 });
  }

  if (event.type === "checkout.session.completed") {
    const session = event.data.object as Stripe.Checkout.Session;

    const offerKey = session.metadata?.offer_key;
    const userId = session.metadata?.user_id;
    const cmsSlug = session.metadata?.cms_slug;

    if (!offerKey || !userId) {
      // log this; it's a config error in CMS
      return new Response("Missing offer_key or user_id", { status: 400 });
    }

    await grantAccessForOffer({
      userId,
      offerKey,
      cmsSlug,
      stripeCustomerId: session.customer as string | null,
      stripeSessionId: session.id,
    });
  }

  // you can add subscription renewal logic for invoice.paid, etc. later

  return new Response("OK", { status: 200 });
}
Now the entitlement logic is completely decoupled from:
payment_intent
product_slug
random product names
Everything funnels through offer_key.
1.4. Centralize entitlements in one Offer Registry function
Create grantAccessForOffer as a single switchboard:
// lib/offers.ts
type GrantAccessParams = {
  userId: string;
  offerKey: string;
  cmsSlug?: string | null;
  stripeCustomerId?: string | null;
  stripeSessionId?: string | null;
};

export async function grantAccessForOffer(params: GrantAccessParams) {
  const { userId, offerKey } = params;

  switch (offerKey) {
    case "ROLLODEX_LIFETIME":
      // insert into user_entitlements, etc
      await grantRolodexLifetime(userId);
      break;

    case "BRANDGUIDE_LIFETIME":
      await grantBrandGuideLifetime(userId);
      break;

    case "DANCE_MONETIZE_LIFETIME":
      await grantDanceMonetizeLifetime(userId);
      break;

    // later: "APE_PRO_MONTHLY", "CSCORE_PRO_MONTHLY", etc
    default:
      // log unknown offer_key, don't crash
      console.warn("Unknown offer_key", { offerKey, userId });
      break;
  }
}
From here on out:
Adding a new paid product =
CMS: add offer_key + primary_price_id
Code: add one case in grantAccessForOffer
That’s the Money Truth fully codified.
2. Verifying SITEMAP is registry-driven
Contract you want:
Sitemap must only include URLs from global_urls where is_indexed = true.
2.1. Implement / verify /sitemap.xml like this
If you haven’t already, your Next.js sitemap route should look something like:
// app/sitemap.xml/route.ts or pages/api/sitemap.xml.ts
import { getIndexedUrls } from "@/lib/url-registry";

export async function GET() {
  const urls = await getIndexedUrls(); // from global_urls

  const origin =
    process.env.NEXT_PUBLIC_SITE_URL ?? "https://yourdomain.com";

  const body = `<?xml version="1.0" encoding="UTF-8"?>
  <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
    ${urls
      .map(
        (u) => `
      <url>
        <loc>${origin}${u.url}</loc>
        ${u.last_modified ? `<lastmod>${u.last_modified.toISOString()}</lastmod>` : ""}
      </url>`,
      )
      .join("\n")}
  </urlset>
  `;

  return new Response(body.trim(), {
    status: 200,
    headers: {
      "Content-Type": "application/xml",
    },
  });
}
And getIndexedUrls should be something like:
// lib/url-registry.ts
import { db } from "@/lib/db";

export async function getIndexedUrls() {
  return db.global_urls.findMany({
    where: { is_indexed: true },
    select: {
      url: true,
      last_modified: true, // optional column
    },
  });
}
Check yourself:
No direct crawling.
No route scanning.
No hardcoded lists.
Sitemap is literally a read of global_urls WHERE is_indexed = true.
If it’s not like this yet, refactor it to be exactly this.
Then your SEO Scanner + Sitemap + Admin toggle are all using the same source of truth.
3. Admin CRUD – quick unification principle
You already noticed the gap:
JSON importer writes cms_objects
URL Registry is managed separately
You don’t have to fix this today, but the correct future flow is:
“Create page” = one unified admin action that:
Writes a cms_object,
Creates or updates a global_urls row
url, type, source_table, source_id, is_indexed = false by default.
That gives you a single button flow later:
“Create Tool”
“Create Product”
“Create Article”
Each one automatically:
Inserts CMS object
Registers URL in global_urls
Leaves is_indexed = false until you approve
Right now your JSON importer already does 1).
Later we can extend it to also do 2).
4. Where you stand after this tightening
Once you wire the above:
CONTENT Truth:
cms_objects is the only place tools/products/articles live.
URL Truth:
global_urls is the only source for:
SEO Scanner
Sitemap
“Index ON/OFF” control
MONEY Truth:
offer_key + primary_price_id in CMS
/api/checkout reads CMS → creates Stripe session with offer_key in metadata
Webhook → grantAccessForOffer(offer_key)
Products table = Stripe plumbing only (optional)
That’s a real, professional-grade architecture.
And yes, once this is in place, the backend actually does become easy glue code from here on.