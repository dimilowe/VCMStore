REPLIT PROMPT: “NAME COMBINER” TOOL
You are building a production-ready micro-tool called “Name Combiner”.
1. Tech stack
Language: JavaScript
Backend: Node.js + Express
Frontend: Vanilla HTML + CSS + minimal JS (no React, no frontend build step)
Templating: EJS or plain HTML served by Express (your choice, but keep it simple)
No database. Everything is computed in memory.
The app will be a single-page tool with one main route and one API route.
2. Project structure
Create this structure:
index.js – main Express server
public/
styles.css – all styling
main.js – frontend JS
views/
index.ejs (or index.html if you don’t use EJS)
package.json – with scripts:
"start": "node index.js"
3. App purpose
A Name Combiner Tool that lets users enter 2–3 names or words and generates a list of merged names.
Use cases:
Couple/ship names
Baby names combining parents’ names
Brand names
Username ideas
Team or group names
We’re targeting keywords like:
“name combiner”
“combine names”
“couple name combiner”
“baby name combiner”
“brand name combiner”
“username combiner”
App must be fast, SEO-friendly, mobile-responsive, and look clean.
4. Backend requirements (Express)
4.1. Server setup
Create an Express app listening on process.env.PORT || 3000.
Serve static files from /public.
Use EJS (or HTML) for the main page template.
4.2. Routes
GET /
Renders the main page with the form and initial SEO content.
POST /api/combine
Accept JSON body:
{
  "name1": "string",
  "name2": "string",
  "name3": "string | optional",
  "style": "string" // one of "balanced", "cute", "edgy", "fantasy", "brandable"
}
Validate input:
At least name1 and name2 required.
Trim whitespace, remove extra spaces.
Return JSON containing:
{
  "baseNames": ["Name1", "Name2", "Name3?"],
  "style": "balanced",
  "suggestions": ["CombinedName1", "CombinedName2", ...] // 20 suggestions
}
4.3. Name-combining algorithm (important)
Implement a deterministic algorithm (no AI, no external APIs). Do all logic in a separate helper file or inside the main file as pure functions.
Algorithm rules:
Normalize:
Keep original capitalization for display, but for processing use lowercase.
Remove special characters except letters and digits.
Generate blends with these patterns (examples assuming alex + marco):
1. Half-and-half blends
First half of name1 + second half of name2
al + rco → alrco
First 3 letters name1 + last 3 letters name2
First 2 letters name1 + full name2
Full name1 + last 2–3 letters name2
Do the symmetric versions with names swapped.
2. Overlap blends
If the end of name1 matches the start of name2 (or similar letters), merge them.
Example: anna + nate → annate
Try 1–3 letter overlaps.
3. Vowel-based blends
Split name1 before its last vowel and name2 after its first vowel.
Example: carla + diego → carliego
Do a few permutations of this.
4. Third-name mixing (optional)
If name3 is provided, occasionally:
Take first syllable or 2–3 letters from each and line them up.
5. Style variations
For each base blend, adjust based on style:
balanced: Just the raw blend.
cute: Add diminutive endings like -y, -ie, -kins, -boo (e.g., Alrie, Marlexie).
edgy: Add sharper endings or tweaks like -x, -yx, -zor, -rix, -vex.
fantasy: Insert extra vowels or consonants to feel fantasy-ish, like -riel, -dor, -thos, -wyn.
brandable: Aim for shorter (4–8 chars), punchy, avoid repeated letters, and capitalize cleanly.
6. Cleanup + uniqueness
Capitalize final outputs in TitleCase.
Remove duplicates.
Filter out any results shorter than 3 characters.
Limit to 20 suggestions max.
Put the combination logic in clearly named functions (e.g., combineNames(name1, name2, name3, style)).
5. Frontend UI/UX (HTML + CSS + JS)
5.1. Layout
Single page layout with:
Header
Logo/text: Name Combiner
Subheading: “Combine two or three names into unique mashups.”
Main form section
Input A: “Name 1” (<input type="text">)
Input B: “Name 2”
Optional Input C: “Name 3 (optional)”
Dropdown for style:
Balanced (default)
Cute
Edgy
Fantasy
Brandable
Large “Generate Names” button.
Results section
Initially shows a placeholder like: “Your combined names will appear here.”
After user clicks generate:
A grid or list of result cards, each with:
The combined name
A “Copy” button
Include a small text above results:
“Showing 20 combined name ideas.”
Secondary CTA / Internal links area
Beneath results, show a small section:
“Next: Turn your favorite name into a brand or project” with placeholder links like:
“Generate a logo (link placeholder)”
“Plan a website around this name (link placeholder)”
Footer
Simple copyright line and space for a link back to main VCM Suite or generic placeholder.
5.2. Styling (styles.css)
Design goals:
Clean, modern, light background.
Centered container with max-width ~900px.
Use a Google Font like Inter, Poppins, or system font stack.
Large, readable inputs.
Big primary button with hover state.
Results shown as pills or cards with subtle shadow.
Mobile responsive:
Inputs and button stack vertically on small screens.
Results grid switches to 1 column on mobile, 2–3 columns on desktop.
No Tailwind or frameworks — just plain CSS.
6. Frontend behavior (main.js)
6.1. Form handling
On form submit (or button click):
Prevent default.
Grab values from input fields and dropdown.
Validate:
Require name1 and name2.
If missing, show a small error message under the form.
Show a “Generating…” state (disable button + small text).
Send a fetch POST request to /api/combine with JSON body.
Example:
fetch('/api/combine', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ name1, name2, name3, style })
})
On success:
Clear the previous results.
If suggestions is empty, show a friendly message:
“No combinations found. Try shorter names or a different style.”
Otherwise, render each suggestion as:
<div class="name-card">CombinedName<button class="copy-btn">Copy</button></div>
6.2. Copy to clipboard
Implement a copyToClipboard(text) function using navigator.clipboard.writeText.
When the user clicks a “Copy” button:
Copy the corresponding name.
Briefly show a tooltip or change button text to “Copied!” then revert.
6.3. Local history (optional but nice)
Optionally store last generated result set in localStorage.
On page load, if there’s a previous result, show it again.
7. SEO & content (very important)
In the main HTML/EJS page, include:
<title>Name Combiner – Combine Names into Unique Mashups (Couples, Baby Names, Brands)</title>
<meta name="description" content="Free name combiner tool. Merge two or three names into unique combinations for couples, baby names, brand ideas, usernames, and more.">
<h1>Name Combiner</h1> visible heading.
Supporting text under the heading explaining use cases in plain language.
Also add a small FAQ section under the tool (static HTML), for SEO:
Questions:
“What is a name combiner?”
“How do I combine two names into one?”
“Can I use the combined names for brands or business names?”
“Is the Name Combiner tool free to use?”
Answer each in 2–3 short sentences.
8. Error handling & edge cases
If backend throws, return 500 with JSON { error: "Something went wrong. Please try again." }.
In frontend, show a simple alert or inline error message.
Trim whitespace and collapse multiple spaces in names.
Handle long names gracefully (truncate/apply max length validation on the frontend, e.g. 40 chars per name).
9. Quality expectations
Code must be clean, well-commented, and logically separated (combination algorithm in helper functions).
No unused dependencies.
Make sure npm install then npm start runs the app with zero errors.
Test with example name pairs:
“Alex” + “Marco”
“Dimi” + “Lowe”
“Sarah” + “Jonathan”
“Luna” + “Ryder”
Verify that it always returns up to 20 unique suggestions.