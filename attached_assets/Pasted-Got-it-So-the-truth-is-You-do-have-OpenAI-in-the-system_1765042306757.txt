Got it. So the truth is:
âœ… You do have OpenAI in the system.
ğŸ¯ Goal = 1000 clusters, thousands of posts where your job is: skim â†’ toggle Published â†’ toggle Indexed.
So letâ€™s stop circling and just spell out exactly what needs to be built given that OpenAI is available inside the app.
Iâ€™ll give you a dev checklist you can literally hand to Replit.
0. Core Principle
The system must be able to do this for any cluster:
Given a cluster â‡’ auto-generate all its articles with OpenAI â‡’ store them as drafts â‡’ you review & toggle.
Everything below is just making that real.
1. Data Model: Store Pregenerated Articles
Decide where generated articles live.
Option A (simplest): use your existing blog_posts table
Add columns:
cluster_slug (string, nullable) â€“ e.g. "calorie-counter"
status ("draft" | "published") â€“ if not already present
is_indexed (boolean, default false)
is_auto_generated (boolean, default true)
generated_at (datetime, default now)
needs_review (boolean, default true)
target_keyword (string, nullable)
featured_image_prompt (string, nullable)
This lets a post be:
tied to a cluster,
auto-generated,
in draft, not indexed,
clearly marked â€œneeds reviewâ€.
No new table needed unless your blog system is a mess.
2. Planned Articles Registry per Cluster
You already conceptually have:
Steps vs Calories Walking
Walking for Fat Loss
What Are Maintenance Calories?
Maintenance vs Deficit vs Surplus
You need this in code so the system knows what to generate.
Create something like:
// lib/clusterArticlesPlan.ts
export type PlannedClusterArticle = {
  title: string;
  slug: string;
  targetKeyword: string;
};

export function getPlannedArticlesForCluster(clusterSlug: string): PlannedClusterArticle[] {
  if (clusterSlug === "calorie-counter") {
    return [
      { title: "Steps vs Calories Walking", slug: "steps-vs-calories-walking", targetKeyword: "steps vs calories walking" },
      { title: "Walking for Fat Loss", slug: "walking-for-fat-loss", targetKeyword: "walking for fat loss" },
      { title: "What Are Maintenance Calories?", slug: "what-are-maintenance-calories", targetKeyword: "what are maintenance calories" },
      { title: "Maintenance vs Deficit vs Surplus", slug: "maintenance-vs-deficit-vs-surplus", targetKeyword: "maintenance vs deficit vs surplus" },
    ];
  }

  // later: wire this into clusterRegistry instead of hardcoding
  return [];
}
Long-term this should read from your clusterRegistry; short-term hardcode calorie cluster and duplicate the pattern.
3. Article Generator Service (OpenAI)
You need one central function that turns a plan into content.
// lib/articleGenerator.ts
import { openai } from "@/lib/openaiClient";

export async function generateClusterArticle(params: {
  title: string;
  slug: string;
  targetKeyword: string;
  clusterSlug: string;
  tools: { name: string; url: string }[];
}): Promise<{
  content: string;
  metaDescription: string;
  featuredImagePrompt: string;
}> {
  const { title, targetKeyword, clusterSlug, tools } = params;

  const toolsText = tools.map(t => `- ${t.name} (${t.url})`).join("\n");

  const prompt = `
You are writing an SEO-optimized article for a health/fitness site.

Cluster: ${clusterSlug}
Article title: ${title}
Target keyword: "${targetKeyword}"
Word count: 1000-1500 words.

Must-haves:
- Start with "# ${title}" as H1.
- Use proper H2/H3 structure.
- Explain what the concept is, why it matters, and how to use it.
- Naturally include the target keyword in the intro, headings, and body.
- Include contextual references to these tools (assume they exist on the same site):
${toolsText}
- Link up to the cluster pillar page.
- Link across to related articles in this cluster where it makes sense (mention them by title, URLs will be connected later).

Tone:
- Direct, practical, no fluff.
- Speak like a coach who wants the reader to actually act on this.

Output:
- Valid markdown only.
`;

  const completion = await openai.responses.create({
    model: "gpt-4.1-mini",
    input: prompt,
  });

  // adjust parsing to your actual OpenAI client response
  const raw = completion.output[0].content[0].text.value ?? completion.output[0].content[0].text;

  const cleaned = String(raw).trim();

  const firstSentence = cleaned
    .replace(/[#*`]/g, "")
    .split(".")
    .slice(0, 2)
    .join(". ")
    .trim();

  const metaDescription =
    firstSentence.length > 155 ? firstSentence.slice(0, 152) + "..." : firstSentence;

  const featuredImagePrompt = `Clean, modern graphic illustrating "${title}" in the context of calories, walking, and fat loss.`;

  return {
    content: cleaned,
    metaDescription,
    featuredImagePrompt,
  };
}
This gives you a reusable â€œarticle factoryâ€.
4. API Route: Generate Articles for a Cluster (Pregeneration)
Route:
POST /api/clusters/[clusterSlug]/generate-articles
Behavior:
Get clusterSlug from params.
Call getPlannedArticlesForCluster(clusterSlug).
For each planned article:
Check if a blog post with that slug already exists.
If yes â†’ skip (idempotent).
If no â†’:
Call generateClusterArticle(...) with appropriate tools list.
Insert into blog_posts with:
title
slug
cluster_slug
content
meta_description
featured_image_prompt
status = "draft"
is_indexed = false
is_auto_generated = true
needs_review = true
generated_at = now()
Thatâ€™s your pre-generation step: everything written, nothing live.
5. Cluster Admin UI: The â€œCheck & Toggleâ€ Screen
Route:
/admin/clusters/[clusterSlug]
This page must show you, for that cluster:
Cluster info (name, slug, target keyword, health score)
Status summary:
e.g. Articles: 4 planned Â· 4 drafts Â· 0 published Â· 0 indexed
Button:
â€œGenerate Articles for This Clusterâ€ â†’ calls the API above.
Then a table listing each article (join planned list + DB):
Columns:
Title
Slug
Status (draft / published)
Indexed (checkbox)
GeneratedAt
Actions:
Preview â€“ quick read-only view of markdown
Edit â€“ opens your existing blog editor
Publish / Unpublish â€“ toggles status via PATCH
You want the UX to literally be:
â€œ4/4 Generated, 0/4 Publishedâ€ â†’ skim â†’ click Publish, toggle Indexed.
6. Public Rendering: Respect Status + is_indexed
Two critical wiring points so the toggles arenâ€™t fake.
6.1. Blog route /blog/[slug]:
If status !== "published" â†’ show 404 (or admin-only preview).
If status = "published":
Render content.
6.2. robots meta:
When rendering <head>:
If is_indexed = false:
<meta name="robots" content="noindex, nofollow" />
If is_indexed = true:
<meta name="robots" content="index, follow" />
6.3. sitemap
In sitemap generation:
Only include blog posts where:
status = "published"
is_indexed = true
Now your â€œIndexedâ€ toggle = real control over Google.
7. Interlinking (Minimum Viable, Not Perfect)
Short-term, donâ€™t overcomplicate:
Pass the pillar URL and tool URLs into the prompt so OpenAI writes references.
Use consistent text anchors:
â€œCalorie Deficit Calculatorâ€
â€œMaintenance Calories Calculatorâ€
etc.
Later you can build a markdown transformer that auto-replaces those phrases with actual links using a map. For now, you just need the model to speak about the tools so the content is thematically linked.
8. Phase 1 Dev TODO (Concrete List)
Hand this to Replit:
Extend blog_posts table
Add: cluster_slug, status, is_indexed, is_auto_generated, generated_at, needs_review, target_keyword, featured_image_prompt.
Create getPlannedArticlesForCluster helper
Hardcode the calorie clusterâ€™s 4 articles as a first implementation.
Add OpenAI client util (lib/openaiClient.ts)
Wrap it in generateClusterArticle(...) that returns markdown + metaDescription + imagePrompt.
Implement POST /api/clusters/[clusterSlug]/generate-articles
Idempotent generator that creates draft blog_posts for all planned slugs in that cluster.
Create GET /api/clusters/[clusterSlug]/articles
Returns all blog_posts tied to cluster_slug plus planned metadata so the admin UI can show coverage.
Build /admin/clusters/[clusterSlug] page
Show summary counts (planned, generated, published, indexed).
Add â€œGenerate Articles for This Clusterâ€ button.
Render table with Preview / Edit / Publish / Indexed toggle.
Add PATCH /api/blog-posts/[id]
Allow updating status and is_indexed via admin.
Wire blog rendering (/blog/[slug])
Respect status for visibility.
Use is_indexed to set robots meta.
Update sitemap generation
Include only status = "published" AND is_indexed = true.
Sanity check cluster health score logic
Make sure it counts â€œarticles existâ€ based on blog_posts with matching cluster_slug.
Once those 10 are done, you have exactly what you said:
A thousand clusters auto-generated with OpenAI, where your daily work is: open cluster â†’ skim â†’ toggle Published â†’ toggle Indexed.
After that, we can talk about scaling up to 100+ clusters and tuning prompts by cluster type, but this is the core spine youâ€™re missing.