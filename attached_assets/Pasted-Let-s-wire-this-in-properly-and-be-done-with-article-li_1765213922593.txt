Let’s wire this in properly and be done with “article limbo.”
I’ll give you drop-in code for:
ArticleForRenderer type
cmsToArticleRenderer mapper
ArticleEngine component
/mbb/[slug]/page.tsx route that pulls from cms_objects and resolves tools + siblings
Adjust import paths / DB client to match your setup (Drizzle/Prisma/etc.), but the structure is correct.
1. Article type – ArticleForRenderer
Create lib/types/article.ts:
// lib/types/article.ts

export type ArticleForRenderer = {
  id: string;
  slug: string;
  title: string;
  description: string | null;
  body: string | null; // markdown or rich text string
  seo: {
    metaTitle: string | null;
    metaDescription: string | null;
    ogImage?: string | null;
  };
  interlinkParent: string | null;
  interlinkSiblings: string[]; // article slugs
  interlinkTools: string[];    // tool slugs
  monetization?: {
    offerKey?: string;
    ctaLabel?: string;
    ctaUrl?: string;
  };
};
2. Mapper: CMS → ArticleForRenderer
Assuming you have a CmsObject type already (from cms_objects):
// lib/render-mappers.ts

import type { ArticleForRenderer } from "./types/article";
// import type { CmsObject } from "./types/cms"; // adjust to your real path

// Shape here should match your cms_objects row / CmsObject type
type CmsObject = {
  id: string;
  type: string;
  slug: string;
  title: string;
  description: string | null;
  body: string | null;
  seo: any;
  interlink_parent: string | null;
  interlink_siblings: string[] | null;
  interlink_tools: string[] | null;
  monetization?: any;
};

export function cmsToArticleRenderer(cms: CmsObject): ArticleForRenderer {
  if (cms.type !== "article") {
    throw new Error(`cmsToArticleRenderer: expected type "article", got "${cms.type}"`);
  }

  const seo = cms.seo ?? {};

  return {
    id: cms.id,
    slug: cms.slug,
    title: cms.title,
    description: cms.description,
    body: cms.body,
    seo: {
      metaTitle: seo.metaTitle ?? cms.title ?? null,
      metaDescription: seo.metaDescription ?? cms.description ?? null,
      ogImage: seo.ogImage ?? null,
    },
    interlinkParent: cms.interlink_parent,
    interlinkSiblings: cms.interlink_siblings ?? [],
    interlinkTools: cms.interlink_tools ?? [],
    monetization: cms.monetization,
  };
}
Tweak the CmsObject type to match your exact Drizzle/Prisma model; the logic stays the same.
3. ArticleEngine component
Create components/renderers/ArticleEngine.tsx:
// components/renderers/ArticleEngine.tsx

"use client";

import React from "react";
import type { ArticleForRenderer } from "@/lib/types/article";
import Link from "next/link";
import ReactMarkdown from "react-markdown";

type RelatedItem = {
  slug: string;
  title: string;
  path: string;
};

type ToolItem = {
  slug: string;
  name: string;
  path: string;
};

type ArticleEngineProps = {
  article: ArticleForRenderer;
  relatedArticles: RelatedItem[];
  relatedTools: ToolItem[];
};

export const ArticleEngine: React.FC<ArticleEngineProps> = ({
  article,
  relatedArticles,
  relatedTools,
}) => {
  const { title, description, body, monetization } = article;

  return (
    <main className="mx-auto max-w-3xl px-4 py-10">
      {/* Breadcrumb / Parent cluster */}
      {article.interlinkParent && (
        <div className="mb-4 text-sm text-gray-500">
          <Link
            href={`/mbb/${article.interlinkParent}`}
            className="hover:underline"
          >
            ← Back to cluster
          </Link>
        </div>
      )}

      {/* Hero */}
      <header className="mb-8">
        <h1 className="text-3xl font-semibold tracking-tight mb-2">
          {title}
        </h1>
        {description && (
          <p className="text-base text-gray-600">{description}</p>
        )}
      </header>

      {/* Monetization CTA (optional, top) */}
      {monetization?.ctaUrl && monetization?.ctaLabel && (
        <div className="mb-8 rounded-xl border border-gray-200 p-4 flex items-center justify-between gap-4">
          <div className="text-sm text-gray-700">
            {monetization.offerKey ? (
              <span className="font-medium">
                Powered by {monetization.offerKey}
              </span>
            ) : (
              <span className="font-medium">Recommended resource</span>
            )}
          </div>
          <a
            href={monetization.ctaUrl}
            className="inline-flex items-center justify-center rounded-full border px-4 py-2 text-sm font-medium hover:bg-gray-50"
          >
            {monetization.ctaLabel}
          </a>
        </div>
      )}

      {/* Body */}
      <article className="prose prose-neutral max-w-none mb-10">
        {body ? (
          <ReactMarkdown>{body}</ReactMarkdown>
        ) : (
          <p className="text-gray-500 text-sm">
            Article content coming soon.
          </p>
        )}
      </article>

      {/* Recommended tools */}
      {relatedTools.length > 0 && (
        <section className="mb-10">
          <h2 className="text-lg font-semibold mb-3">
            Recommended tools
          </h2>
          <div className="grid gap-3 sm:grid-cols-2">
            {relatedTools.map((tool) => (
              <Link
                key={tool.slug}
                href={tool.path}
                className="block rounded-xl border border-gray-200 p-3 hover:border-gray-300 hover:bg-gray-50 transition"
              >
                <div className="text-sm font-medium mb-1">
                  {tool.name}
                </div>
                <div className="text-xs text-gray-500">
                  {tool.path}
                </div>
              </Link>
            ))}
          </div>
        </section>
      )}

      {/* Related articles */}
      {relatedArticles.length > 0 && (
        <section className="mb-4">
          <h2 className="text-lg font-semibold mb-3">
            Related articles
          </h2>
          <div className="space-y-2">
            {relatedArticles.map((a) => (
              <Link
                key={a.slug}
                href={a.path}
                className="block rounded-lg px-3 py-2 hover:bg-gray-50 transition"
              >
                <div className="text-sm font-medium">{a.title}</div>
                <div className="text-xs text-gray-500">{a.path}</div>
              </Link>
            ))}
          </div>
        </section>
      )}
    </main>
  );
};
You already use Tailwind, so this will fit your aesthetic and can be tweaked later.
If you don’t have react-markdown installed, add it:
npm install react-markdown
4. Route: /mbb/[slug]/page.tsx
This pulls the article CMS object, resolves tools and sibling articles, maps everything to the props ArticleEngine expects.
Adjust DB imports (db, cms_objects, etc.) to your actual setup.
// app/mbb/[slug]/page.tsx

import { notFound } from "next/navigation";
import { db } from "@/lib/db"; // adjust
import { cms_objects } from "@/lib/db/schema"; // adjust
import { eq, and, inArray } from "drizzle-orm"; // or your ORM
import { cmsToArticleRenderer } from "@/lib/render-mappers";
import { ArticleEngine } from "@/components/renderers/ArticleEngine";

type PageProps = {
  params: { slug: string };
};

export default async function MbbArticlePage({ params }: PageProps) {
  const { slug } = params;

  // 1. Fetch article CMS object
  const [cmsArticle] = await db
    .select()
    .from(cms_objects)
    .where(
      and(
        eq(cms_objects.type, "article"),
        eq(cms_objects.slug, slug)
      )
    )
    .limit(1);

  if (!cmsArticle) {
    notFound();
  }

  const article = cmsToArticleRenderer(cmsArticle);

  // 2. Fetch related tools by slug
  let relatedTools: { slug: string; name: string; path: string }[] = [];
  if (article.interlinkTools.length > 0) {
    const toolCms = await db
      .select({
        slug: cms_objects.slug,
        title: cms_objects.title,
      })
      .from(cms_objects)
      .where(
        and(
          eq(cms_objects.type, "tool"),
          inArray(cms_objects.slug, article.interlinkTools)
        )
      );

    relatedTools = toolCms.map((t) => ({
      slug: t.slug,
      name: t.title,
      path: `/tools/${t.slug}`,
    }));
  }

  // 3. Fetch related siblings by slug
  let relatedArticles: { slug: string; title: string; path: string }[] = [];
  if (article.interlinkSiblings.length > 0) {
    const siblingCms = await db
      .select({
        slug: cms_objects.slug,
        title: cms_objects.title,
      })
      .from(cms_objects)
      .where(
        and(
          eq(cms_objects.type, "article"),
          inArray(cms_objects.slug, article.interlinkSiblings)
        )
      );

    relatedArticles = siblingCms.map((a) => ({
      slug: a.slug,
      title: a.title,
      path: `/mbb/${a.slug}`,
    }));
  }

  return (
    <ArticleEngine
      article={article}
      relatedArticles={relatedArticles}
      relatedTools={relatedTools}
    />
  );
}
If you aren’t using Drizzle, the query shape changes but the logic is identical:
fetch article from CMS by type + slug
map CMS → ArticleForRenderer
look up related tools and sibling articles by slug arrays
pass all of that to ArticleEngine
What this gives you immediately
With this wired:
Any cms_objects row with type = 'article'
plus the right slug (mbb/[slug])
plus interlink_tools / interlink_siblings arrays
…will render as a full article page, with:
Body content
“Recommended tools” block
“Related articles” block
Cluster breadcrumb
And because your JSON bulk-import + global_urls already exist, your flow for clusters becomes:
Mega prompt → article CMS JSON (with interlinking + tools).
POST to /api/admin/cms/bulk-import.
/mbb/[slug] works instantly for every article.
You flip is_indexed in your URL admin when ready.
No extra patchwork.
