Build a production-ready free image hosting micro tool for bloggers, similar to Postimg.cc, using Node.js + Express. The app should let users upload an image and get back:
A direct image URL (served via our CDN domain)
An HTML <img> snippet
A Markdown snippet
A BBCode snippet
The tool will be the “VCM Image Host” and is intended for public hotlinking, but with sane limits and basic abuse protection.
1. Tech Stack
Backend: Node.js + Express
Frontend: Simple HTML/CSS/vanilla JS (single-page app)
File upload: multer (or similar) for handling multipart/form-data
Environment config: dotenv
Security/middleware:
helmet
cors
compression
express-rate-limit
Cloud storage: Cloudflare R2 using its S3-compatible API via @aws-sdk/client-s3
No database needed for v1 — just generate unique keys and store images directly in R2. All necessary info can be derived from the key and env config.
2. Environment Variables
Use a .env file and never hard-code secrets. Expect the following env vars:
PORT – default 3000
NODE_ENV – "development" or "production"
CLOUDFLARE_R2_ACCOUNT_ID
CLOUDFLARE_R2_ACCESS_KEY_ID
CLOUDFLARE_R2_SECRET_ACCESS_KEY
CLOUDFLARE_R2_BUCKET_NAME
R2_PUBLIC_BASE_URL – e.g. https://img.vcmsuite.com
(This will be the public CDN domain fronting the R2 bucket.)
Use the AWS S3 endpoint format for R2:
https://${CLOUDFLARE_R2_ACCOUNT_ID}.r2.cloudflarestorage.com
Objects should be stored under a simple flat key like:
images/<randomSlug>.<ext>
3. Backend Behavior
Create an Express app with:
Middleware
helmet() for basic security headers
compression() for gzip
cors() allowing all origins (this is a public tool)
JSON + URL-encoded body parsers for any API work
A global rate limiter via express-rate-limit, e.g.:
Window: 1 hour
Max requests: e.g. 60 per IP/hour
Rate limiting applies to the upload endpoint especially
File Upload Handling
Use multer with:
Single file field: file
Max file size: e.g. 5 MB (configurable via env, MAX_FILE_SIZE_BYTES)
Accept only image content types:
image/jpeg
image/png
image/webp
image/gif (optional, but allow)
Reject anything else with a 400 and JSON error.
Also do a basic extension check based on the original filename.
Route: POST /api/upload
Accept multipart/form-data with file as the key.
Validate:
File exists
MIME type is allowed
Size under limit
Generate a random slug (e.g. 10–12 chars, alphanumeric).
Infer the extension from the MIME type (.jpg, .png, .webp, .gif).
Compose an object key:
const objectKey = `images/${slug}${ext}`;
Upload the file buffer to Cloudflare R2 using @aws-sdk/client-s3:
Use PutObjectCommand
Bucket: CLOUDFLARE_R2_BUCKET_NAME
Key: objectKey
ContentType: actual MIME type
ACL: default private is fine — R2 is public behind CDN; assume the CDN is configured to expose the bucket.
After successful upload, construct the public URL:
const directUrl = `${process.env.R2_PUBLIC_BASE_URL}/${objectKey}`;
Return JSON:
{
  "success": true,
  "slug": "abc123xyz",
  "directUrl": "https://img.vcmsuite.com/images/abc123xyz.jpg",
  "html": "<img src=\"https://img.vcmsuite.com/images/abc123xyz.jpg\" alt=\"Hosted image\" />",
  "markdown": "![Hosted image](https://img.vcmsuite.com/images/abc123xyz.jpg)",
  "bbcode": "[img]https://img.vcmsuite.com/images/abc123xyz.jpg[/img]"
}
Handle and log errors cleanly. Return 500 with { success: false, error: "message" } on failures.
Optional Route: GET /health
Return { status: "ok" } for uptime checks.
4. Cloudflare R2 Setup (Code Assumptions)
Use @aws-sdk/client-s3 and configure it like this:
Endpoint: https://${CLOUDFLARE_R2_ACCOUNT_ID}.r2.cloudflarestorage.com
Region: "auto" or "us-east-1" (R2 ignores region but requires a string)
Credentials: CLOUDFLARE_R2_ACCESS_KEY_ID + CLOUDFLARE_R2_SECRET_ACCESS_KEY
Example client (in TypeScript or JS):
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";

const s3 = new S3Client({
  region: "auto",
  endpoint: `https://${process.env.CLOUDFLARE_R2_ACCOUNT_ID}.r2.cloudflarestorage.com`,
  credentials: {
    accessKeyId: process.env.CLOUDFLARE_R2_ACCESS_KEY_ID,
    secretAccessKey: process.env.CLOUDFLARE_R2_SECRET_ACCESS_KEY,
  },
});
Then use PutObjectCommand in the upload route.
5. Frontend (Single Page)
Create a minimal but clean single-page UI at /:
Centered card layout
Title: VCM Image Host
Subtitle: “Free hotlinkable image hosting for bloggers.”
Components:
Drag-and-drop area
Standard <input type="file" accept="image/*">
Upload button
Status area for:
Uploading spinner / message
Success message
Error messages
After upload succeeds, display:
Preview of the image (using directUrl)
Copyable text boxes for:
Direct URL
HTML snippet
Markdown snippet
BBCode snippet
Use a small “Copy” button next to each snippet that uses the Clipboard API (navigator.clipboard.writeText).
Styling:
Use simple responsive CSS
Light, modern design
Make it look like a polished micro tool, not boilerplate
No frameworks needed — just vanilla JS. Use fetch to POST the file to /api/upload.
6. Validation & Abuse Protection
Add some basic guardrails:
Rate limiting on /api/upload as mentioned.
Only images allowed (reject others).
Max file size 5 MB (or via env var).
Server logs should include:
Timestamp
IP (from req.ip)
File size
MIME type
Whether upload succeeded or failed
You do NOT need auth in v1 — this is a public free tool.
7. Project Structure
Organize files like this:
/
  package.json
  .env.example
  src/
    server.js (or server.ts)
    routes/
      upload.js
    lib/
      r2Client.js
      slug.js
  public/
    index.html
    styles.css
    app.js
Make sure npm start runs the app on PORT.
8. README
Include a README that explains:
What the tool does
How to configure .env
How to run locally (npm install, npm start)
How to deploy (Replit + Cloudflare R2 + CDN)
Security / limits (images only, max file size, rate limiting)
9. Final Touches
Return consistent JSON from the API (always include success boolean).
Make the front-end show clear error messages when upload fails.
Ensure CORS is configured to allow cross-site embedding of the hosted images (but that’s mainly on Cloudflare/CDN; here just keep cors() permissive).
Please generate all the necessary code files, including:
package.json with all dependencies
src code for server, routes, and R2 client
public/index.html, public/styles.css, public/app.js
.env.example
README.md
This should be a fully working, production-leaning image hosting micro tool suitable as a free utility on VCM Suite.