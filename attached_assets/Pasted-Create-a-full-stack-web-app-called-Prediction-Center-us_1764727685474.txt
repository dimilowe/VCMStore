Create a full-stack web app called "Prediction Center" using Node.js, Express, EJS, SQLite, and TailwindCSS (via CDN, no build tools).

Purpose:
A lightweight, no-auth prediction app where people submit future-event questions and vote YES/NO. No money, no payouts. Just questions, votes, percentages, and resolution.

Tech stack:
- Node.js + Express
- EJS for server-rendered views
- SQLite database using better-sqlite3
- cookie-parser for cookies
- TailwindCSS included via CDN in the EJS layout

Project structure:
- server.js                     # main Express app
- db.js                         # SQLite connection + schema init + helper functions
- views/
  - layout.ejs                  # common HTML layout with Tailwind CDN
  - index.ejs                   # homepage listing predictions + submission form
  - prediction.ejs              # single prediction page
- public/
  - main.js                     # client-side JS for AJAX voting
  - styles.css                  # optional custom styles if needed
- package.json

Environment variable:
- ADMIN_KEY: used to protect ONLY the resolve route with header x-admin-key

Database schema:
Use better-sqlite3 and automatically create tables if they don't exist.

Table: predictions
- id INTEGER PRIMARY KEY AUTOINCREMENT
- question TEXT NOT NULL
- description TEXT
- category TEXT
- created_at TEXT NOT NULL      -- ISO string
- close_date TEXT               -- ISO string or NULL
- status TEXT NOT NULL DEFAULT 'open'   -- 'open' or 'resolved'
- outcome TEXT                  -- 'yes' | 'no' | NULL

Table: votes
- id INTEGER PRIMARY KEY AUTOINCREMENT
- prediction_id INTEGER NOT NULL
- anon_id TEXT NOT NULL
- choice TEXT NOT NULL          -- 'yes' | 'no'
- created_at TEXT NOT NULL
- UNIQUE(prediction_id, anon_id) ON CONFLICT IGNORE
Add a foreign key from votes.prediction_id to predictions.id.

Cookies / anon logic:
- Use cookie-parser.
- On every request, check for cookie named "prediction_anon_id".
- If it does not exist, generate a random UUID (using crypto.randomUUID()) and set the cookie with a long expiration.
- When inserting into votes, always use this anon_id.
- The UNIQUE(prediction_id, anon_id) constraint should enforce one vote per user per prediction. If insertion fails due to conflict, handle it gracefully in code and respond with HTTP 409 + JSON { error: "Already voted" }.

Routes:

1) GET /
- Query all predictions ordered by created_at DESC (show open first, then resolved).
- For each prediction, compute:
  - totalVotes
  - yesCount
  - noCount
  - yesPercent and noPercent as integers (0–100, handle divide-by-zero).
- Render views/index.ejs with:
  - predictions: array of objects { id, question, category, close_date, status, totalVotes, yesPercent, noPercent }
  - and include at the top a simple form to submit a new prediction:
    - fields: question (required), description (optional textarea), category (optional), closeDate (optional date input).
    - form posts to POST /predictions.

2) POST /predictions   (PUBLIC submission, no auth)
- Body (urlencoded form): { question, description, category, closeDate }.
- Basic validation:
  - question is required and max 200 characters.
  - description max 1000 characters.
  - category max 50 characters.
- Insert a new prediction with:
  - status='open'
  - outcome=NULL
  - created_at = current ISO timestamp
  - close_date = parsed closeDate or NULL.
- On success, redirect back to '/' so the new prediction appears in the list.

3) GET /prediction/:id
- Load a single prediction by id.
- Load vote counts (yesCount, noCount, totalVotes).
- Compute yesPercent and noPercent.
- Render views/prediction.ejs with:
  - prediction object
  - stats: { yesCount, noCount, totalVotes, yesPercent, noPercent }

4) POST /prediction/:id/vote (JSON)
- Body: { choice: 'yes' | 'no' }.
- Validate that choice is 'yes' or 'no'.
- Look up prediction; if not found or status != 'open', return HTTP 400.
- Insert into votes with (prediction_id, anon_id from cookie, choice, created_at).
- If UNIQUE constraint prevents insertion (user already voted), return HTTP 409 with { error: 'Already voted' }.
- On success, recompute yesCount, noCount, totalVotes, yesPercent, noPercent and return JSON:
  {
    yesCount,
    noCount,
    totalVotes,
    yesPercent,
    noPercent
  }

5) POST /admin/predictions/:id/resolve
- Protect this route by checking header 'x-admin-key'; if it does not equal process.env.ADMIN_KEY, return HTTP 401.
- Body: { outcome: 'yes' | 'no' }.
- Update prediction with given id:
  - status='resolved'
  - outcome = outcome
- Return JSON { success: true }.
- After resolution, voting endpoint should reject further votes with HTTP 400.

Views:

layout.ejs:
- HTML5 boilerplate.
- Include TailwindCSS via CDN in <head>.
- A simple header with title "Prediction Center".
- Use <main> to render body content via <%- body %>.

index.ejs:
- Top section:
  - Hero: title "Prediction Center", subtitle "Submit predictions, vote yes/no, and see what the crowd thinks."
  - New prediction form posting to /predictions.
- Below, list predictions.
- For each prediction, show:
  - question as a link to /prediction/:id
  - category badge if present
  - status badge "Open" (green) or "Resolved" (gray, with outcome label if resolved)
  - close date formatted as "Closes on X" if present
  - a horizontal bar showing yesPercent vs noPercent using Tailwind utility classes
  - text "Yes XX% · No YY% · N votes"

prediction.ejs:
- Show question as big heading.
- Show description (if any).
- Show category and status badge.
- If prediction.status === 'resolved':
  - Show final outcome: "Resolved: YES" or "Resolved: NO"
  - Do NOT show vote buttons.
- If prediction.status === 'open':
  - Show two buttons:
    - "Vote YES" (green Tailwind button)
    - "Vote NO" (red Tailwind button)
  - Buttons should trigger fetch POST /prediction/:id/vote with choice=yes or choice=no using main.js.
- Below, show stats:
  - yesPercent %, noPercent %, totalVotes.
  - A larger horizontal bar visual.

Client-side JS (public/main.js):
- On prediction page, attach click listeners to YES and NO buttons.
- On click:
  - Disable buttons.
  - Send fetch POST to /prediction/:id/vote with JSON body { choice }.
  - If response 200, update counts and percentages in the DOM.
  - If 409 (already voted), show "You already voted on this prediction."
  - If 400, show "Voting is closed for this prediction."
  - Re-enable buttons if appropriate.

General:
- Serve static files from /public via express.static.
- Listen on process.env.PORT or 3000 by default.
- Add basic error handling middleware (log error and return 500 for unexpected errors).

Also seed the database on first run with 3 example predictions in db.js:
1) "Will OpenAI's ChatGPT be considered the 'Best AI' by the end of 2025?"
2) "Will TikTok be banned in the United States by the end of 2025?"
3) "Will Bitcoin trade above $100,000 at any point in 2026?"

Each with status='open' and null outcome.

Make sure the app runs successfully with 'node server.js' and the homepage shows the seeded predictions and the submission form.
