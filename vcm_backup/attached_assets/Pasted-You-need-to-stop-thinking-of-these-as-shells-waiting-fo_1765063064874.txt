You need to stop thinking of these as “shells waiting for manual pages” and start treating /tools/[slug] as the one dynamic renderer for everything.
What’s going on now
Legacy tools (keyword-finder, logo-generator, etc.) = hard-coded pages.
New tools (YouTube metrics, blueprint expansions) = DB entries only, no React page.
That’s why preview links work up to the URL level, then die.
If you keep building one-off pages for each tool, you’ve just killed the whole point of C.A.S.E.
What you actually should do
1. Yes, create a dynamic catch-all route: /tools/[slug]/page.tsx
And it should do this:
Grab slug from params.
const tool = await getToolBySlug(slug);
If no tool → 404.
If tool exists:
If tool.engine is supported → render real engine UI.
If tool.engine is not implemented yet → show “Coming soon” shell with metadata (title, description, keywords).
Pseudo-code:
// app/tools/[slug]/page.tsx
import { getToolBySlug } from "@/lib/toolsRepo";
import { notFound } from "next/navigation";
import { ENGINE_COMPONENTS } from "@/lib/engineRegistry";

export default async function ToolPage({ params }: { params: { slug: string } }) {
  const tool = await getToolBySlug(params.slug);

  if (!tool) {
    return notFound();
  }

  const EngineComponent = ENGINE_COMPONENTS[tool.engine];

  if (!EngineComponent) {
    // Fallback: shell exists, engine not wired yet
    return (
      <ToolComingSoon tool={tool} />
    );
  }

  return <EngineComponent tool={tool} />;
}
That’s it. Now every shell is routable.
2. Don’t make static pages for new tools anymore
Static pages were fine when you had 10–20 tools.
You have:
an engine system
a tool table
blueprints
shells being mass-generated
So:
Legacy hand-coded tools: fine, leave them for now.
New tools: must go through /tools/[slug] + engine logic.
Over time, you can refactor legacy tools to also be engine-based and drop their static files.
3. “Coming soon” is acceptable only as a fallback
Use “coming soon” only when:
tool.engine is not implemented yet or
you haven’t built the specific engine client for that category.
You should still render:
Tool title
Description
Maybe the future input/output concept
“This tool is part of the YouTube Metrics cluster” with internal link to the pillar.
So you can:
Click it from Cluster Control Panel
See that it exists and is wired
Use it as a checklist for which engines you’ve actually built
4. For YouTube Metrics specifically
Do this:
Add calculator engine to ENGINE_COMPONENTS.
Build a YouTubeMetricsCalculatorClient that:
Reads the tool’s dimensions JSON (metric + content_type)
Selects a preset: inputs + formula + labels
For now, if you’re not ready for formulas, show:
Basic input form
Placeholder output
But don’t hide behind “coming soon” unless you truly haven’t wired anything.
Answering your question directly
“Would you like me to create a dynamic catch-all route that at least shows a nice ‘coming soon’ page for tool shells?”
Yes.
But don’t stop at “coming soon”.
Do this:
Create /tools/[slug]/page.tsx using ToolsRepo + engine registry.
Implement “Coming Soon” only as fallback when tool.engine has no component.
Start wiring real engines (calculator, resizer, hashtag generator, etc.) so blueprint shells become real tools without you touching filesystem files.