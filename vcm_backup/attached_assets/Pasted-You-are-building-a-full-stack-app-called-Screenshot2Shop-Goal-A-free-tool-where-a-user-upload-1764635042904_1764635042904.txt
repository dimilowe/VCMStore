You are building a full-stack app called **Screenshot2Shop**.

Goal:
A free tool where a user uploads an image (e.g., screenshot of an outfit, room, product, etc.) and gets a list of visually similar products with links. The app uses OpenAI Vision to understand the image, then calls a shopping search API to find similar products.

STACK
- Node.js + Express for backend (TypeScript)
- React + Vite for frontend (TypeScript)
- Tailwind CSS for styling (keep it simple, clean, minimal)
- Use Multer for file uploads (memory storage, limit file size to ~5MB)
- Use `openai` npm package for Vision (gpt-4.1-mini or latest vision-capable model)
- Use SerpAPI *Google Shopping* (or a generic shopping search) for product results

ENV VARIABLES
Create a `.env` file with:
- `OPENAI_API_KEY` = OpenAI API key with Vision access
- `SERPAPI_API_KEY` = SerpAPI key (Google Shopping engine)
- `PORT` = 3000 (default)

If `SERPAPI_API_KEY` is missing, the backend should still work but instead of hitting SerpAPI, it should just generate regular Google search URLs using the keywords and return those as “unstructured” results.

FOLDER / FILE STRUCTURE
- `/server`
  - `index.ts` (Express app entry)
  - `routes/analyze.ts` (image analysis + product search route)
  - `types.ts` (shared types/interfaces)
- `/client`
  - `index.html`
  - `src/main.tsx`
  - `src/App.tsx`
  - `src/components/UploadForm.tsx`
  - `src/components/ResultsGrid.tsx`
  - `src/types.ts`
- `/shared`
  - `prompts.ts` (system prompt for Vision)
- `package.json`
- `vite.config.ts`
- `tailwind.config.cjs`
- `postcss.config.cjs`
- `tsconfig.json`

BACKEND LOGIC

1. Express Setup (`server/index.ts`)
   - Enable CORS for the frontend origin.
   - Use JSON + URL-encoded middleware.
   - Serve static client build in production.
   - Register `/api/analyze-image` POST route.
   - Add a simple `/health` GET route that returns `{ status: "ok" }`.

2. Image Upload + Validation (`routes/analyze.ts`)
   - Use Multer with memory storage to accept one file field named `image`.
   - Accept only image MIME types (`image/jpeg`, `image/png`, `image/webp`).
   - Reject files larger than 5MB with a sensible error response.
   - If no image is provided, return `400` with `{ error: "Image is required" }`.

3. Call OpenAI Vision
   - Use `openai` client.
   - Model: `gpt-4.1-mini` (or latest vision capable).
   - Pass the uploaded image as a base64 data URL.
   - Use a **system prompt** that forces structured JSON output:

     Example system prompt (put in `/shared/prompts.ts`):
     ```
     You are a product-matching assistant. Given an image, you identify distinct visually-sellable items (clothes, accessories, furniture, gadgets, decor, etc.) and output CLEAN JSON.

     For each item, infer:
     - a concise label (2–4 words)
     - a natural language description (1–2 sentences)
     - a list of keyword phrases suitable for shopping searches (5–10, specific but not brand-dependent)

     Return JSON only in this shape:
     {
       "detected_items": [
         {
           "label": "string",
           "description": "string",
           "search_keywords": ["string", ...]
         }
       ]
     }

     Do not include any extra text outside JSON.
     ```

   - On success, parse the JSON from the model output and validate its shape. If parsing fails, return a `500` with `{ error: "Vision parsing failed" }`.

4. Shopping Search (SerpAPI)
   - For each detected item, take the **first few search keywords** and build a query string, e.g. `"white cropped ribbed knit sweater women"`.
   - If `SERPAPI_API_KEY` is present:
     - Call `https://serpapi.com/search.json` with:
       - `engine=google_shopping`
       - `q=<search query>`
       - `api_key=<SERPAPI_API_KEY>`
       - `num=8` (max products per item)
     - From each result, extract:
       - title
       - price (if available)
       - thumbnail / image URL
       - source / merchant name
       - product URL
     - If the SerpAPI call fails or returns no items, fall back to generating a plain Google search URL.
   - If `SERPAPI_API_KEY` is not set:
     - Skip API call and simply generate a Google search URL based on the keywords:
       `https://www.google.com/search?tbm=shop&q=${encodeURIComponent(query)}`
     - Return this URL as a single generic result with `isExternalSearchLink = true`.

5. Response Shape
   - The final JSON response to the frontend should look like:

     ```ts
     interface DetectedItem {
       label: string;
       description: string;
       searchKeywords: string[];
     }

     interface ProductResult {
       title: string;
       price?: string;
       imageUrl?: string;
       source?: string;
       productUrl: string;
       externalSearchLink?: boolean; // true for plain Google search URL fallback
     }

     interface AnalyzeResponse {
       items: Array<{
         detectedItem: DetectedItem;
         products: ProductResult[];
       }>;
     }
     ```

   - Return `200` with this structure.

6. Error Handling
   - On predictable errors (bad file type, no file, too big) → `400` with `{ error }`.
   - On OpenAI or SerpAPI failure → log full error server-side, return `502` with `{ error: "Upstream service error" }`.
   - Always respond with JSON from `/api/analyze-image`.

FRONTEND LOGIC

1. App Layout (`client/src/App.tsx`)
   - A centered, one-column layout.
   - Top: Title “Screenshot → Shop”
   - Subtitle: “Upload any outfit or aesthetic photo and we’ll find similar products.”
   - Show `UploadForm` and below it the `ResultsGrid`.
   - Maintain state for:
     - selected image preview
     - loading flag
     - error string
     - results (`AnalyzeResponse`)

2. Upload Form (`UploadForm.tsx`)
   - Props:
     - `onResults(response: AnalyzeResponse): void`
     - `onError(message: string): void`
     - `onLoadingChange(isLoading: boolean): void`
     - `onPreviewChange(previewUrl: string | null): void`
   - UI:
     - Drag-and-drop area + “Browse” button for file picker.
     - Only accept `image/*`.
     - Show tiny note: “Max 5MB. JPG/PNG/WEBP.”
   - Behavior:
     - When user selects/drops a file:
       - Show preview image (via `URL.createObjectURL`).
       - Submit to `/api/analyze-image` using `FormData`.
       - Set `loading=true` while waiting.
       - On success → call `onResults`.
       - On error → show message and call `onError`.
       - Always toggle loading appropriately.

3. Results Grid (`ResultsGrid.tsx`)
   - Props: `results: AnalyzeResponse | null`
   - If no results yet, show a simple “Upload an image to see results.”
   - For each `item` in `results.items`:
     - Show the detected item label as section header.
     - Under it, show the description and keyword chips.
     - Below, render product cards in a responsive grid (2–4 columns).
   - Each product card displays:
     - Product image (or a placeholder if missing)
     - Title (truncate to 1–2 lines)
     - Price if available
     - Source/merchant
   - Clicking a card:
     - Opens `productUrl` in a new tab.
     - (IMPORTANT: route through a redirect endpoint for future monetization, see below.)

4. Future APE Integration (Redirect routing)
   - Instead of linking directly to `productUrl`, cards should point to a backend redirect route like `/r?u=<encodedUrl>`.
   - For now, implement `/r` in Express:
     - Read `u` query param.
     - Optionally log click info (timestamp, item label, IP hash, user agent).
     - Redirect with `302` to the decoded URL.
   - This makes it trivial later to:
     - Insert APE tracking
     - Wrap links with affiliate codes
     - Add split payouts or other OS logic.

STYLING
- Use Tailwind for quick styling.
- Dark-on-light, clean, minimal.
- Key CSS goals:
  - Centered main card with max width (e.g., `max-w-4xl mx-auto`).
  - Drag-and-drop area with dashed border and hover effect.
  - Image preview with rounded corners and subtle shadow.
  - Product grid with responsive columns (`grid-cols-1 sm:grid-cols-2 md:grid-cols-3`).
  - Clear loading state with a simple spinner or text “Analyzing your image…”

BUILD & RUN
- Add npm scripts:
  - `"dev": "concurrently \"npm:dev:server\" \"npm:dev:client\""` 
  - `"dev:server": "ts-node-dev --respawn --transpile-only server/index.ts"`
  - `"dev:client": "vite --config client/vite.config.ts"`
  - `"build": "cd client && npm run build"`
- Configure Vite dev server to proxy `/api` and `/health` and `/r` to the Node server.
- Configure Replit `run` command to use `npm run dev` for development.

UX EDGE CASES
- Show a clear message if:
  - No distinct items were found in the image.
  - Only external search links are available (no structured shopping API).
- Allow user to upload a new image at any time, clearing old results.
- Make sure multiple quick uploads cancel or ignore previous responses to avoid race conditions.

EXTRA (OPTIONAL BUT NICE)
- Add a small “About this tool” section at the bottom explaining:
  - “We use AI to understand your photo, then search the web for similar products.”
  - Disclaimer: “Results and prices are approximate. Always verify details before purchasing.”
- Add a footer CTA box:
  - “Creators: want to monetize your own content? This tool is part of the VCM Suite. [Button: Learn More]”
  - For now, this button can just link to a placeholder URL `https://vcmsuite.com` or a configurable env var.

Deliverable:
A fully working Screenshot2Shop app that:
1) accepts image upload,
2) uses OpenAI Vision to extract product-style keywords,
3) searches for similar products via SerpAPI (or falls back to generic Google Shopping URLs),
4) returns structured JSON to the frontend,
5) displays product matches in a nice grid,
6) routes all outbound clicks through a redirect route for future APE integration.
