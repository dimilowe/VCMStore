You are building a production-ready web app called “Internal Link in SEO Audit Tool”.
The goal:
Let users input either a domain or a sitemap URL.
Fetch the sitemap, crawl up to 150 URLs, parse internal links, and produce an internal linking audit.
The landing page must be SEO-optimized for the keyword phrase “internal link in SEO”.
Tech Stack
Language: Node.js
Framework: Express
Templating / views: EJS or simple server-rendered HTML (no React needed).
HTTP client: axios
XML parsing: fast-xml-parser or similar.
HTML parsing: cheerio
Styling: simple, clean CSS (Tailwind not required).
Set up the project with:
index.js (main server)
views/ for EJS templates
public/ for CSS
Routes
GET /
Render the main landing page with:
H1: Internal Link in SEO: Free Internal Linking Audit Tool
Short hero text explaining what an internal link in SEO is and what the tool does.
A form with:
Text input name="url" (accepts either https://example.com or https://example.com/sitemap.xml)
Submit button: “Run Internal Link Audit”
Include basic SEO tags:
<title>Internal Link in SEO: Free Internal Linking Audit Tool & Guide</title>
<meta name="description" content="Run a free internal link in SEO audit. Paste your domain or sitemap URL and instantly find orphan pages, weak internal links, and easy SEO wins.">
Also, below the form, render a section with static educational content using the keyword “internal link in SEO” naturally a few times (this can be a simplified version of the article the user gave you, but don’t over-optimize).
POST /scan
Accept req.body.url.
Normalize the input:
If it ends with .xml → treat as sitemap URL.
Else → assume it’s a domain and try to auto-detect sitemap at:
${domain}/sitemap.xml
${domain}/sitemap_index.xml
If both fail, respond with an error message shown nicely on the page.
Fetch the sitemap with axios (set a reasonable timeout, e.g. 8–10 seconds).
Parse XML and extract up to 150 URLs:
Support both <urlset><url><loc> and sitemap indexes.
If a sitemap index is found, just take the first few child sitemaps and merge up to 150 URLs total.
For each URL:
Fetch HTML (again with timeout).
Parse with cheerio.
Extract all <a> tags:
Take the href.
Normalize:
Ignore mailto:, tel:, javascript:, #fragment links.
Convert relative URLs to absolute using the page URL.
Keep only URLs on the same hostname as the original domain.
Build an adjacency graph:
Maintain a map keyed by URL:
outboundInternalLinks: number
inboundInternalLinks: number
title: string | null
When page A links to B:
Increment A’s outboundInternalLinks
Increment B’s inboundInternalLinks
After processing all pages, compute:
Orphan pages: inboundInternalLinks === 0
Weakly linked pages: inboundInternalLinks between 1 and 2
Top linked pages: sort by inboundInternalLinks descending, show top 10.
Important: Handle errors gracefully.
If fetching a page fails, skip it but don’t crash the whole scan.
Track how many pages were successfully scanned vs skipped.
GET /results
You can either:
Redirect to /results after a successful scan with data stored in memory, or
Render results directly in the POST /scan response.
For simplicity, rendering from POST /scan is fine.
Results Page Layout (from POST /scan)
Render a results view (EJS) with the following sections:
Summary section (top)
Pages scanned: X
Orphan pages found: Y
Average internal links per page: Z (average of outboundInternalLinks)
A one-sentence insight that includes the phrase “internal link in SEO”, e.g.:
“Improving your internal link in SEO strategy starts with fixing these orphan pages and boosting links to under-connected content.”
Orphaned Pages table
Title: Orphaned Pages (0 inbound internal links)
Columns: URL, Title, Inbound Internal Links, Outbound Internal Links
Only show pages with inboundInternalLinks === 0.
If none, show “Good news — no orphan pages were detected.”
Weakly Linked Pages table
Title: Weak Pages (1–2 inbound internal links)
Same columns.
Include a small note above:
“These pages are receiving very little internal link equity. Adding more internal links to them is an easy SEO win.”
Top Linked Pages table
Title: Top Linked Pages
Sort by inboundInternalLinks descending, show top 10.
Columns: URL, Title, Inbound Internal Links, Outbound Internal Links
Actionable Suggestions section
Render a simple bullet list based on the computed data:
E.g.,
“Start by adding internal links from your top 5 most linked pages to your 5 orphan pages.”
“Consider turning your best-linked pages into pillar content and clustering related articles around them.”
Mention “internal link in SEO” naturally in this section once.
All tables should be responsive and readable on mobile.
UX & Design
Use a very clean layout:
max-width container (~900px),
light background,
clear headings,
alternating row background colors for tables.
Show a loading state after submitting the form (“Scanning your internal links… this can take a minute.”).
If any error occurs (invalid sitemap, cannot fetch, etc.), show a friendly message on the same page and give them a link back to the form.
SEO Requirements
Main landing page / must:
Use the keyword phrase “internal link in SEO” in:
Title tag
H1
Meta description
First paragraph of body copy
Include a short FAQ section at the bottom with questions like:
“What is an internal link in SEO?”
“Do internal links help SEO rankings?”
“How many internal links should I use per page?”
The FAQs should be in plain HTML, no schema needed for this MVP.
Do not keyword stuff; use the exact phrase “internal link in SEO” naturally 3–5 times across the landing page.
Code Quality
Use async/await with try/catch.
Put crawl logic in a separate module (e.g. crawler.js) for clarity.
Add comments explaining:
how sitemap is fetched,
how URLs are limited to 150,
how internal vs external links are decided.
When finished, the app should run with node index.js and listen on port 3000 (or process.env.PORT if set).
This tool must be fully functional end-to-end:
form → sitemap fetch → crawl → compute stats → render results page.